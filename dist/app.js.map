{
  "version": 3,
  "sources": ["../src/element-utils.ts", "../src/app.ts"],
  "sourcesContent": ["// Element utilities for checking if words can be spelled with element symbols\n\n// Get all valid element symbols from the periodic table with correct capitalization\nconst elements: string[] = [\n  'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', \n  'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', \n  'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', \n  'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', \n  'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', \n  'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', \n  'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', \n  'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', \n  'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', \n  'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', \n  'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', \n  'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'E'\n];\n\n// Create case-insensitive element set for comparisons\nconst elementSetLower: Set<string> = new Set(elements.map(e => e.toLowerCase()));\n\n// Elements map with correct capitalization for output\nconst elementMap: {[key: string]: string} = {};\nelements.forEach(e => {\n  elementMap[e.toLowerCase()] = e;\n});\n\n/**\n * Check if a word or phrase can be spelled using only element symbols\n * @param wordOrPhrase The word or phrase to check\n * @returns false if not possible, or an array of permutations (each permutation is an array of element symbols with special '_SPACE_' marker for word boundaries)\n */\nexport function canBeSpelledWithElements(wordOrPhrase: string): string[][] | false {\n  // Split the input by spaces to handle multiple words\n  const words = wordOrPhrase.split(' ').filter(word => word.length > 0);\n  if (words.length === 0) return false;\n  \n  // If it's just one word, use the original algorithm\n  if (words.length === 1) {\n    return processWord(words[0]);\n  }\n  \n  // Process each word separately\n  const wordPermutations: string[][][] = [];\n  for (const word of words) {\n    const permutations = processWord(word);\n    if (!permutations) return false; // If any word can't be spelled, the whole phrase can't be spelled\n    wordPermutations.push(permutations);\n  }\n  \n  // Combine permutations from all words with space markers\n  return combineWordPermutations(wordPermutations);\n}\n\n/**\n * Process a single word to find all possible ways to spell it with elements\n * @param word A single word without spaces\n * @returns false if not possible, or an array of permutations\n */\nfunction processWord(word: string): string[][] | false {\n  word = word.toLowerCase();\n  \n  // Dynamic programming approach to find all possible ways to split the word\n  const dp: boolean[] = new Array(word.length + 1).fill(false);\n  dp[0] = true; // Empty string can always be formed\n  \n  // To store all possible decompositions\n  // elementPathsAt[i] contains all possible ways to decompose word[0...i-1]\n  const elementPathsAt: string[][][] = new Array(word.length + 1);\n  elementPathsAt[0] = [[]]; // Empty path for position 0\n  \n  for (let i = 1; i <= word.length; i++) {\n    elementPathsAt[i] = [];\n    \n    // Try to form word[0...i-1] using element symbols\n    for (let j = 1; j <= Math.min(i, 2); j++) {  // Element symbols are at most 2 characters\n      const symbol = word.substring(i - j, i);\n      \n      if (dp[i - j] && elementSetLower.has(symbol)) {\n        dp[i] = true;\n        \n        // For each path that leads to position (i-j), append this symbol\n        for (const path of elementPathsAt[i - j]) {\n          elementPathsAt[i].push([...path, elementMap[symbol]]);\n        }\n      }\n    }\n  }\n  \n  return dp[word.length] ? elementPathsAt[word.length] : false;\n}\n\n/**\n * Combines permutations from multiple words, adding a space marker between words\n * @param wordPermutations Array of permutations for each word\n * @returns Combined permutations with space markers\n */\nfunction combineWordPermutations(wordPermutations: string[][][]): string[][] {\n  // Start with first word's permutations\n  let result = wordPermutations[0];\n  \n  // Combine with each subsequent word\n  for (let i = 1; i < wordPermutations.length; i++) {\n    const newResult: string[][] = [];\n    \n    // For each existing permutation...\n    for (const existingPath of result) {\n      // ...combine with each permutation of the current word\n      for (const newPath of wordPermutations[i]) {\n        // Add space marker between words\n        newResult.push([...existingPath, '_SPACE_', ...newPath]);\n      }\n    }\n    \n    result = newResult;\n  }\n  \n  return result;\n}\n", "// Element word visualizer application\nimport { canBeSpelledWithElements } from './element-utils';\n\n// Function to modify SVG content to make it responsive and theme-aware\nfunction makeSvgResponsive(svgContent: string): string {\n    return svgContent\n        .replace(/<rect([^>]*)fill=\"white\"/, '<rect$1fill=\"var(--bg-color)\"')\n        .replace(/<text([^>]*?)>([^<]*)<\\/text>/g, '<text$1 fill=\"var(--text-color)\">$2</text>')\n        .replace(/<svg([^>]*)/, '<svg$1 class=\"element-svg-content\"')\n        .replace(/stroke=\"black\"/g, 'stroke=\"var(--text-color)\"');\n}\n\n// Function to create a downloadable SVG from a permutation row\nfunction downloadPermutationAsSVG(permutationRow: HTMLElement, word: string): void {\n    // Get all SVG elements in the permutation row\n    const svgElements = permutationRow.querySelectorAll('.element-svg-content');\n    if (!svgElements.length) return;\n    \n    // Get computed colors from CSS variables for SVG export\n    const computedStyle = getComputedStyle(document.body);\n    const bgColor = computedStyle.getPropertyValue('--bg-color').trim();\n    const textColor = computedStyle.getPropertyValue('--text-color').trim();\n    \n    // Calculate dimensions based on the SVG elements\n    let totalWidth = 0;\n    let maxHeight = 0;\n    \n    // Calculate total width and maximum height\n    svgElements.forEach((svg) => {\n        const svgElement = svg as SVGSVGElement;\n        totalWidth += svgElement.getBoundingClientRect().width;\n        maxHeight = Math.max(maxHeight, svgElement.getBoundingClientRect().height);\n    });\n    \n    // Add some padding\n    totalWidth += (svgElements.length - 1) * 10;  // 10px spacing between elements\n    totalWidth += 20;  // 10px padding on each side\n    maxHeight += 20;   // 10px padding on top and bottom\n    \n    // Start creating the combined SVG\n    const combinedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    combinedSvg.setAttribute('width', totalWidth.toString());\n    combinedSvg.setAttribute('height', maxHeight.toString());\n    combinedSvg.setAttribute('viewBox', `0 0 ${totalWidth} ${maxHeight}`);\n    combinedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    \n    // Set background color based on current theme (using actual RGB color instead of variable)\n    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    bgRect.setAttribute('width', '100%');\n    bgRect.setAttribute('height', '100%');\n    bgRect.setAttribute('fill', computedStyle.backgroundColor);\n    combinedSvg.appendChild(bgRect);\n    \n    // Group to hold all the elements\n    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    \n    // Current X position for placing elements\n    let currentX = 10;  // Start with 10px padding\n    \n    // Process each SVG element\n    svgElements.forEach((svg) => {\n        const svgElement = svg as SVGSVGElement;\n        const width = svgElement.getBoundingClientRect().width;\n        const height = svgElement.getBoundingClientRect().height;\n        \n        // Instead of extracting content, generate a new SVG for each element\n        // Get the original SVG's XML content\n        const svgString = new XMLSerializer().serializeToString(svgElement);\n        \n        // Create a new SVG from scratch with proper positioning\n        const elementSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n        elementSvg.setAttribute('width', width.toString());\n        elementSvg.setAttribute('height', height.toString());\n        elementSvg.setAttribute('x', currentX.toString());\n        elementSvg.setAttribute('y', ((maxHeight - height) / 2).toString());\n        \n        // Parse the original SVG content as a document\n        const parser = new DOMParser();\n        const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');\n        const originalSvg = svgDoc.documentElement;\n        \n        // Get the viewBox from the original SVG to preserve aspect ratio and positioning\n        if (originalSvg.hasAttribute('viewBox')) {\n            elementSvg.setAttribute('viewBox', originalSvg.getAttribute('viewBox')!);\n        }\n        \n        // Replace CSS variables with computed values in the SVG content\n        const replaceVarsInElement = (el: Element) => {\n            // Handle text elements\n            if (el.tagName.toLowerCase() === 'text' && el.hasAttribute('fill')) {\n                const fillValue = el.getAttribute('fill');\n                if (fillValue?.includes('var(--')) {\n                    el.setAttribute('fill', computedStyle.color);\n                }\n            }\n            \n            // Handle rect elements\n            if (el.tagName.toLowerCase() === 'rect' && el.hasAttribute('fill')) {\n                const fillValue = el.getAttribute('fill');\n                if (fillValue?.includes('var(--')) {\n                    if (fillValue?.includes('--bg-color')) {\n                        el.setAttribute('fill', computedStyle.backgroundColor);\n                    }\n                }\n            }\n            \n            // Handle stroke attributes on any element\n            if (el.hasAttribute('stroke')) {\n                const strokeValue = el.getAttribute('stroke');\n                if (strokeValue?.includes('var(--')) {\n                    el.setAttribute('stroke', computedStyle.color);\n                }\n            }\n            \n            // Process children recursively\n            Array.from(el.children).forEach(child => {\n                replaceVarsInElement(child);\n            });\n        };\n        \n        // Import and copy all child nodes from the original SVG\n        // This preserves their original positions\n        Array.from(originalSvg.childNodes).forEach(child => {\n            const importedNode = document.importNode(child, true);\n            if (importedNode.nodeType === Node.ELEMENT_NODE) {\n                replaceVarsInElement(importedNode as Element);\n            }\n            elementSvg.appendChild(importedNode);\n        });\n        \n        group.appendChild(elementSvg);\n        currentX += width + 10;  // Add spacing\n    });\n    \n    combinedSvg.appendChild(group);\n    \n    // Convert SVG to a data URI\n    const svgData = new XMLSerializer().serializeToString(combinedSvg);\n    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });\n    const svgUrl = URL.createObjectURL(svgBlob);\n    \n    // Create a download link\n    const downloadLink = document.createElement('a');\n    downloadLink.href = svgUrl;\n    downloadLink.download = `${word.replace(/\\s+/g, '-')}-elements.svg`;\n    \n    // Trigger download\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n    \n    // Clean up the URL object\n    setTimeout(() => {\n        URL.revokeObjectURL(svgUrl);\n    }, 100);\n}\n\n// Function to create a shareable URL and copy to clipboard\nfunction shareUrl(word: string): void {\n    // Create URL with the current word as a parameter\n    const url = new URL(window.location.href);\n    url.search = new URLSearchParams({ word }).toString();\n    \n    // Copy to clipboard\n    navigator.clipboard.writeText(url.toString())\n        .then(() => {\n            // Show toast notification\n            const toast = document.getElementById('toast');\n            if (toast) {\n                toast.classList.add('show');\n                \n                // Hide toast after 3 seconds\n                setTimeout(() => {\n                    toast.classList.remove('show');\n                }, 3000);\n            }\n        })\n        .catch(err => {\n            console.error('Failed to copy URL: ', err);\n            alert('Failed to copy the share link to clipboard.');\n        });\n}\n\n// Theme management\nfunction setTheme(theme: 'light' | 'dark'): void {\n    if (theme === 'dark') {\n        document.body.classList.add('dark-mode');\n    } else {\n        document.body.classList.remove('dark-mode');\n    }\n}\n\n// Function to get URL query parameters\nfunction getQueryParam(param: string): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get(param);\n}\n\n// Function to process word input\nfunction processWordInput(word: string, elementContainer: HTMLElement, resultDiv: HTMLElement): void {\n    // Clear previous results\n    elementContainer.innerHTML = '';\n    resultDiv.textContent = '';\n    \n    // Get share button\n    const shareButton = document.getElementById('share-button') as HTMLButtonElement;\n    \n    // Disable the share button by default\n    if (shareButton) {\n        shareButton.disabled = true;\n    }\n    \n    if (!word) {\n        return;\n    }\n    \n    // Check if the word/phrase can be spelled using element symbols\n    const elementPermutations = canBeSpelledWithElements(word);\n    \n    if (elementPermutations && elementPermutations.length > 0) {\n        // Word/phrase can be spelled with element symbols\n        resultDiv.textContent = `\"${word}\" can be spelled in ${elementPermutations.length} different way${elementPermutations.length > 1 ? 's' : ''}`;\n        \n        // Enable the share button if the word can be spelled\n        if (shareButton) {\n            shareButton.disabled = false;\n        }\n        \n        // Create a map to cache SVGs so we don't reload them for each permutation\n        const svgCache: Record<string, string> = {};\n        \n        // Process each permutation\n        elementPermutations.forEach((elementPath, permutationIndex) => {\n            // Create a container for this permutation\n            const permutationRow = document.createElement('div');\n            permutationRow.className = 'permutation-row';\n            \n            elementContainer.appendChild(permutationRow);\n            \n            // Define the result type to handle different cases\n            type ElementResult = \n                | { element: string; isSpace: true; }\n                | { element: string; svgContent: string; }\n                | { element: string; error: true; };\n                \n            // Array to store promises for this permutation's SVG loads\n            const loadPromises = elementPath.map(element => {\n                // Skip processing for space markers - will be handled later\n                if (element === '_SPACE_') {\n                    return Promise.resolve({\n                        element: '_SPACE_',\n                        isSpace: true as const\n                    });\n                }\n                \n                // Use cached SVG if available\n                if (svgCache[element]) {\n                    return Promise.resolve({\n                        element,\n                        svgContent: svgCache[element]\n                    });\n                }\n                \n                // Otherwise, fetch the SVG\n                return fetch(`./elements/${element.toLowerCase()}.svg`)\n                    .then(response => {\n                        if (!response.ok) {\n                            throw new Error(`SVG for ${element} not found`);\n                        }\n                        return response.text();\n                    })\n                    .then(svgContent => {\n                        // Cache the SVG\n                        svgCache[element] = svgContent;\n                        return {\n                            element,\n                            svgContent\n                        };\n                    })\n                    .catch(error => {\n                        console.error(error);\n                        return {\n                            element,\n                            error: true as const\n                        };\n                    });\n            });\n            \n            // When all SVGs for this permutation are loaded, add them to the container in the correct order\n            Promise.all(loadPromises)\n                .then((results: ElementResult[]) => {\n                    // Group elements into words\n                    let currentWord = document.createElement('div');\n                    currentWord.className = 'element-word';\n                    permutationRow.appendChild(currentWord);\n                    \n                    results.forEach(result => {\n                        // Handle space marker - create a new word container\n                        if ('isSpace' in result && result.isSpace) {\n                            currentWord = document.createElement('div');\n                            currentWord.className = 'element-word';\n                            permutationRow.appendChild(currentWord);\n                            return;\n                        }\n                        \n                        const elementDiv = document.createElement('div');\n                        elementDiv.className = 'element-svg';\n                        \n                        if ('error' in result && result.error) {\n                            elementDiv.textContent = `Error loading ${result.element}`;\n                        } else if ('svgContent' in result) {\n                            // Make SVG responsive\n                            elementDiv.innerHTML = makeSvgResponsive(result.svgContent);\n                        }\n                        \n                        // Add the element to the current word container\n                        currentWord.appendChild(elementDiv);\n                    });\n                    \n                    // Add download button for this permutation\n                    const downloadButton = document.createElement('button');\n                    downloadButton.className = 'download-svg-button';\n                    downloadButton.title = 'Download SVG';\n                    downloadButton.innerHTML = `\n                        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n                            <path d=\"M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z\"/>\n                            <path d=\"M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z\"/>\n                        </svg>\n                    `;\n                    permutationRow.appendChild(downloadButton);\n                    \n                    // Set up download button click handler\n                    downloadButton.addEventListener('click', () => {\n                        downloadPermutationAsSVG(permutationRow, word);\n                    });\n                });\n        });\n    } else {\n        // Word/phrase cannot be spelled with element symbols\n        resultDiv.textContent = `\"${word}\" cannot be spelled using only chemical elements`;\n        \n        // Keep share button disabled since the word can't be spelled\n        if (shareButton) {\n            shareButton.disabled = true;\n        }\n    }\n}\n\n// Initialize the application\ndocument.addEventListener('DOMContentLoaded', () => {\n    const form = document.getElementById('word-form') as HTMLFormElement;\n    const wordInput = document.getElementById('word-input') as HTMLInputElement;\n    const resultDiv = document.getElementById('result') as HTMLDivElement;\n    const elementContainer = document.getElementById('element-container') as HTMLDivElement;\n    const themeRadios = document.querySelectorAll('input[name=\"theme\"]') as NodeListOf<HTMLInputElement>;\n    const shareButton = document.getElementById('share-button') as HTMLButtonElement;\n    \n    // Check for query parameter 'word'\n    const wordFromParam = getQueryParam('word');\n    \n    // Set up theme toggle event listeners\n    themeRadios.forEach(radio => {\n        radio.addEventListener('change', (e) => {\n            const target = e.target as HTMLInputElement;\n            setTheme(target.value as 'light' | 'dark');\n        });\n    });\n    \n    // Set up share button click handler\n    shareButton.addEventListener('click', () => {\n        // Only proceed if button is not disabled\n        if (!shareButton.disabled) {\n            const inputText = wordInput.value.trim();\n            if (inputText) {\n                shareUrl(inputText);\n            }\n        }\n    });\n    \n    // Prevent default form submission but still keep the form for accessibility\n    form.addEventListener('submit', (e) => {\n        e.preventDefault();\n    });\n    \n    // Process input as user types\n    wordInput.addEventListener('input', () => {\n        const inputText = wordInput.value.trim();\n        processWordInput(inputText, elementContainer, resultDiv);\n    });\n    \n    // If there's a word parameter in the URL, use it to auto-populate input field\n    if (wordFromParam) {\n        wordInput.value = wordFromParam;\n        processWordInput(wordFromParam, elementContainer, resultDiv);\n    } else {\n        // Ensure share button is disabled initially\n        shareButton.disabled = true;\n    }\n});\n"],
  "mappings": "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",
  "names": []
}

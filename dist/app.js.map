{
  "version": 3,
  "sources": ["../src/element-utils.ts", "../src/app.ts"],
  "sourcesContent": ["// Element utilities for checking if words can be spelled with element symbols\n\n// Get all valid element symbols from the periodic table with correct capitalization\nconst elements: string[] = [\n  'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', \n  'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', \n  'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', \n  'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', \n  'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', \n  'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', \n  'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', \n  'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', \n  'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', \n  'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', \n  'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', \n  'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'E'\n];\n\n// Create case-insensitive element set for comparisons\nconst elementSetLower: Set<string> = new Set(elements.map(e => e.toLowerCase()));\n\n// Elements map with correct capitalization for output\nconst elementMap: {[key: string]: string} = {};\nelements.forEach(e => {\n  elementMap[e.toLowerCase()] = e;\n});\n\n/**\n * Check if a word or phrase can be spelled using only element symbols\n * @param wordOrPhrase The word or phrase to check\n * @returns false if not possible, or an array of permutations (each permutation is an array of element symbols with special '_SPACE_' marker for word boundaries)\n */\nexport function canBeSpelledWithElements(wordOrPhrase: string): string[][] | false {\n  // Split the input by spaces to handle multiple words\n  const words = wordOrPhrase.split(' ').filter(word => word.length > 0);\n  if (words.length === 0) return false;\n  \n  // If it's just one word, use the original algorithm\n  if (words.length === 1) {\n    return processWord(words[0]);\n  }\n  \n  // Process each word separately\n  const wordPermutations: string[][][] = [];\n  for (const word of words) {\n    const permutations = processWord(word);\n    if (!permutations) return false; // If any word can't be spelled, the whole phrase can't be spelled\n    wordPermutations.push(permutations);\n  }\n  \n  // Combine permutations from all words with space markers\n  return combineWordPermutations(wordPermutations);\n}\n\n/**\n * Process a single word to find all possible ways to spell it with elements\n * @param word A single word without spaces\n * @returns false if not possible, or an array of permutations\n */\nfunction processWord(word: string): string[][] | false {\n  word = word.toLowerCase();\n  \n  // Dynamic programming approach to find all possible ways to split the word\n  const dp: boolean[] = new Array(word.length + 1).fill(false);\n  dp[0] = true; // Empty string can always be formed\n  \n  // To store all possible decompositions\n  // elementPathsAt[i] contains all possible ways to decompose word[0...i-1]\n  const elementPathsAt: string[][][] = new Array(word.length + 1);\n  elementPathsAt[0] = [[]]; // Empty path for position 0\n  \n  for (let i = 1; i <= word.length; i++) {\n    elementPathsAt[i] = [];\n    \n    // Try to form word[0...i-1] using element symbols\n    for (let j = 1; j <= Math.min(i, 2); j++) {  // Element symbols are at most 2 characters\n      const symbol = word.substring(i - j, i);\n      \n      if (dp[i - j] && elementSetLower.has(symbol)) {\n        dp[i] = true;\n        \n        // For each path that leads to position (i-j), append this symbol\n        for (const path of elementPathsAt[i - j]) {\n          elementPathsAt[i].push([...path, elementMap[symbol]]);\n        }\n      }\n    }\n  }\n  \n  return dp[word.length] ? elementPathsAt[word.length] : false;\n}\n\n/**\n * Combines permutations from multiple words, adding a space marker between words\n * @param wordPermutations Array of permutations for each word\n * @returns Combined permutations with space markers\n */\nfunction combineWordPermutations(wordPermutations: string[][][]): string[][] {\n  // Start with first word's permutations\n  let result = wordPermutations[0];\n  \n  // Combine with each subsequent word\n  for (let i = 1; i < wordPermutations.length; i++) {\n    const newResult: string[][] = [];\n    \n    // For each existing permutation...\n    for (const existingPath of result) {\n      // ...combine with each permutation of the current word\n      for (const newPath of wordPermutations[i]) {\n        // Add space marker between words\n        newResult.push([...existingPath, '_SPACE_', ...newPath]);\n      }\n    }\n    \n    result = newResult;\n  }\n  \n  return result;\n}\n", "// Element word visualizer application\nimport { canBeSpelledWithElements } from './element-utils';\n\n// Function to modify SVG content to make it responsive and theme-aware\nfunction makeSvgResponsive(svgContent: string): string {\n    return svgContent\n        .replace(/<rect([^>]*)fill=\"white\"/, '<rect$1fill=\"var(--bg-color)\"')\n        .replace(/<text([^>]*?)>([^<]*)<\\/text>/g, '<text$1 fill=\"var(--text-color)\">$2</text>')\n        .replace(/<svg([^>]*)/, '<svg$1 class=\"element-svg-content\"')\n        .replace(/stroke=\"black\"/g, 'stroke=\"var(--text-color)\"');\n}\n\n// Function to create a shareable URL and copy to clipboard\nfunction shareUrl(word: string): void {\n    // Create URL with the current word as a parameter\n    const url = new URL(window.location.href);\n    url.search = new URLSearchParams({ word }).toString();\n    \n    // Copy to clipboard\n    navigator.clipboard.writeText(url.toString())\n        .then(() => {\n            // Show toast notification\n            const toast = document.getElementById('toast');\n            if (toast) {\n                toast.classList.add('show');\n                \n                // Hide toast after 3 seconds\n                setTimeout(() => {\n                    toast.classList.remove('show');\n                }, 3000);\n            }\n        })\n        .catch(err => {\n            console.error('Failed to copy URL: ', err);\n            alert('Failed to copy the share link to clipboard.');\n        });\n}\n\n// Theme management\nfunction setTheme(theme: 'light' | 'dark'): void {\n    if (theme === 'dark') {\n        document.body.classList.add('dark-mode');\n    } else {\n        document.body.classList.remove('dark-mode');\n    }\n}\n\n// Function to get URL query parameters\nfunction getQueryParam(param: string): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get(param);\n}\n\n// Function to process word input\nfunction processWordInput(word: string, elementContainer: HTMLElement, resultDiv: HTMLElement): void {\n    // Clear previous results\n    elementContainer.innerHTML = '';\n    resultDiv.textContent = '';\n    \n    // Get share button\n    const shareButton = document.getElementById('share-button') as HTMLButtonElement;\n    \n    // Disable the share button by default\n    if (shareButton) {\n        shareButton.disabled = true;\n    }\n    \n    if (!word) {\n        return;\n    }\n    \n    // Check if the word/phrase can be spelled using element symbols\n    const elementPermutations = canBeSpelledWithElements(word);\n    \n    if (elementPermutations && elementPermutations.length > 0) {\n        // Word/phrase can be spelled with element symbols\n        resultDiv.textContent = `\"${word}\" can be spelled in ${elementPermutations.length} different way${elementPermutations.length > 1 ? 's' : ''}`;\n        \n        // Enable the share button if the word can be spelled\n        if (shareButton) {\n            shareButton.disabled = false;\n        }\n        \n        // Create a map to cache SVGs so we don't reload them for each permutation\n        const svgCache: Record<string, string> = {};\n        \n        // Process each permutation\n        elementPermutations.forEach((elementPath, permutationIndex) => {\n            // Create a container for this permutation\n            const permutationRow = document.createElement('div');\n            permutationRow.className = 'permutation-row';\n            \n            elementContainer.appendChild(permutationRow);\n            \n            // Define the result type to handle different cases\n            type ElementResult = \n                | { element: string; isSpace: true; }\n                | { element: string; svgContent: string; }\n                | { element: string; error: true; };\n                \n            // Array to store promises for this permutation's SVG loads\n            const loadPromises = elementPath.map(element => {\n                // Skip processing for space markers - will be handled later\n                if (element === '_SPACE_') {\n                    return Promise.resolve({\n                        element: '_SPACE_',\n                        isSpace: true as const\n                    });\n                }\n                \n                // Use cached SVG if available\n                if (svgCache[element]) {\n                    return Promise.resolve({\n                        element,\n                        svgContent: svgCache[element]\n                    });\n                }\n                \n                // Otherwise, fetch the SVG\n                return fetch(`./elements/${element.toLowerCase()}.svg`)\n                    .then(response => {\n                        if (!response.ok) {\n                            throw new Error(`SVG for ${element} not found`);\n                        }\n                        return response.text();\n                    })\n                    .then(svgContent => {\n                        // Cache the SVG\n                        svgCache[element] = svgContent;\n                        return {\n                            element,\n                            svgContent\n                        };\n                    })\n                    .catch(error => {\n                        console.error(error);\n                        return {\n                            element,\n                            error: true as const\n                        };\n                    });\n            });\n            \n            // When all SVGs for this permutation are loaded, add them to the container in the correct order\n            Promise.all(loadPromises)\n                .then((results: ElementResult[]) => {\n                    // Group elements into words\n                    let currentWord = document.createElement('div');\n                    currentWord.className = 'element-word';\n                    permutationRow.appendChild(currentWord);\n                    \n                    // Track all word spacers in this permutation\n                    const spacers: HTMLElement[] = [];\n                    \n                    // Track spaces between words\n                    let inWord = true;\n                    \n                    results.forEach(result => {\n                        // Handle space marker - create a new word container\n                        if ('isSpace' in result && result.isSpace) {\n                            const spacerDiv = document.createElement('div');\n                            spacerDiv.className = 'word-spacer';\n                            permutationRow.appendChild(spacerDiv);\n                            spacers.push(spacerDiv);\n                            \n                            // Start a new word container after the spacer\n                            currentWord = document.createElement('div');\n                            currentWord.className = 'element-word';\n                            permutationRow.appendChild(currentWord);\n                            inWord = true; // Mark that we're starting a new word\n                            return;\n                        }\n                        \n                        const elementDiv = document.createElement('div');\n                        elementDiv.className = 'element-svg';\n                        \n                        if ('error' in result && result.error) {\n                            elementDiv.textContent = `Error loading ${result.element}`;\n                        } else if ('svgContent' in result) {\n                            // Make SVG responsive\n                            elementDiv.innerHTML = makeSvgResponsive(result.svgContent);\n                        }\n                        \n                        // Add the element to the current word container\n                        currentWord.appendChild(elementDiv);\n                    });\n                    \n                    // Function to check spacer visibility based on word wrapping\n                    const updateSpacerVisibility = () => {\n                        spacers.forEach(spacer => {\n                            const prevWord = spacer.previousElementSibling as HTMLElement;\n                            const nextWord = spacer.nextElementSibling as HTMLElement;\n                            \n                            if (prevWord && nextWord) {\n                                const prevRect = prevWord.getBoundingClientRect();\n                                const nextRect = nextWord.getBoundingClientRect();\n                                \n                                // If words are not on the same line, hide the spacer\n                                if (Math.abs(prevRect.top - nextRect.top) > 10) {\n                                    spacer.classList.add('word-spacer-hidden');\n                                } else {\n                                    spacer.classList.remove('word-spacer-hidden');\n                                }\n                            }\n                        });\n                    };\n                    \n                    // Check initially after rendering and on window resize\n                    setTimeout(updateSpacerVisibility, 10);\n                    window.addEventListener('resize', updateSpacerVisibility);\n                });\n        });\n    } else {\n        // Word/phrase cannot be spelled with element symbols\n        resultDiv.textContent = `\"${word}\" cannot be spelled using only chemical elements`;\n        \n        // Keep share button disabled since the word can't be spelled\n        if (shareButton) {\n            shareButton.disabled = true;\n        }\n    }\n}\n\n// Initialize the application\ndocument.addEventListener('DOMContentLoaded', () => {\n    const form = document.getElementById('word-form') as HTMLFormElement;\n    const wordInput = document.getElementById('word-input') as HTMLInputElement;\n    const resultDiv = document.getElementById('result') as HTMLDivElement;\n    const elementContainer = document.getElementById('element-container') as HTMLDivElement;\n    const themeRadios = document.querySelectorAll('input[name=\"theme\"]') as NodeListOf<HTMLInputElement>;\n    const shareButton = document.getElementById('share-button') as HTMLButtonElement;\n    \n    // Check for query parameter 'word'\n    const wordFromParam = getQueryParam('word');\n    \n    // Set up theme toggle event listeners\n    themeRadios.forEach(radio => {\n        radio.addEventListener('change', (e) => {\n            const target = e.target as HTMLInputElement;\n            setTheme(target.value as 'light' | 'dark');\n        });\n    });\n    \n    // Set up share button click handler\n    shareButton.addEventListener('click', () => {\n        // Only proceed if button is not disabled\n        if (!shareButton.disabled) {\n            const inputText = wordInput.value.trim();\n            if (inputText) {\n                shareUrl(inputText);\n            }\n        }\n    });\n    \n    // Prevent default form submission but still keep the form for accessibility\n    form.addEventListener('submit', (e) => {\n        e.preventDefault();\n    });\n    \n    // Process input as user types\n    wordInput.addEventListener('input', () => {\n        const inputText = wordInput.value.trim();\n        processWordInput(inputText, elementContainer, resultDiv);\n    });\n    \n    // If there's a word parameter in the URL, use it to auto-populate input field\n    if (wordFromParam) {\n        wordInput.value = wordFromParam;\n        processWordInput(wordFromParam, elementContainer, resultDiv);\n    } else {\n        // Ensure share button is disabled initially\n        shareButton.disabled = true;\n    }\n});\n"],
  "mappings": "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",
  "names": []
}

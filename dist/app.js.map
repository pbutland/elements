{
  "version": 3,
  "sources": ["../src/element-utils.ts", "../src/app.ts"],
  "sourcesContent": ["// Element utilities for checking if words can be spelled with element symbols\n\n// Get all valid element symbols from the periodic table with correct capitalization\nconst elements: string[] = [\n  'H', 'He', 'Li', 'Be', 'B', 'C', 'N', 'O', 'F', 'Ne', \n  'Na', 'Mg', 'Al', 'Si', 'P', 'S', 'Cl', 'Ar', 'K', 'Ca', \n  'Sc', 'Ti', 'V', 'Cr', 'Mn', 'Fe', 'Co', 'Ni', 'Cu', 'Zn', \n  'Ga', 'Ge', 'As', 'Se', 'Br', 'Kr', 'Rb', 'Sr', 'Y', 'Zr', \n  'Nb', 'Mo', 'Tc', 'Ru', 'Rh', 'Pd', 'Ag', 'Cd', 'In', 'Sn', \n  'Sb', 'Te', 'I', 'Xe', 'Cs', 'Ba', 'La', 'Ce', 'Pr', 'Nd', \n  'Pm', 'Sm', 'Eu', 'Gd', 'Tb', 'Dy', 'Ho', 'Er', 'Tm', 'Yb', \n  'Lu', 'Hf', 'Ta', 'W', 'Re', 'Os', 'Ir', 'Pt', 'Au', 'Hg', \n  'Tl', 'Pb', 'Bi', 'Po', 'At', 'Rn', 'Fr', 'Ra', 'Ac', 'Th', \n  'Pa', 'U', 'Np', 'Pu', 'Am', 'Cm', 'Bk', 'Cf', 'Es', 'Fm', \n  'Md', 'No', 'Lr', 'Rf', 'Db', 'Sg', 'Bh', 'Hs', 'Mt', 'Ds', \n  'Rg', 'Cn', 'Nh', 'Fl', 'Mc', 'Lv', 'Ts', 'Og', 'E'\n];\n\n// Create case-insensitive element set for comparisons\nconst elementSetLower: Set<string> = new Set(elements.map(e => e.toLowerCase()));\n\n// Elements map with correct capitalization for output\nconst elementMap: {[key: string]: string} = {};\nelements.forEach(e => {\n  elementMap[e.toLowerCase()] = e;\n});\n\n/**\n * Check if a word or phrase can be spelled using only element symbols\n * @param wordOrPhrase The word or phrase to check\n * @returns false if not possible, or an array of permutations (each permutation is an array of element symbols with special '_SPACE_' marker for word boundaries)\n */\nexport function canBeSpelledWithElements(wordOrPhrase: string): string[][] | false {\n  // Split the input by spaces to handle multiple words\n  const words = wordOrPhrase.split(' ').filter(word => word.length > 0);\n  if (words.length === 0) return false;\n  \n  // If it's just one word, use the original algorithm\n  if (words.length === 1) {\n    return processWord(words[0]);\n  }\n  \n  // Process each word separately\n  const wordPermutations: string[][][] = [];\n  for (const word of words) {\n    const permutations = processWord(word);\n    if (!permutations) return false; // If any word can't be spelled, the whole phrase can't be spelled\n    wordPermutations.push(permutations);\n  }\n  \n  // Combine permutations from all words with space markers\n  return combineWordPermutations(wordPermutations);\n}\n\n/**\n * Process a single word to find all possible ways to spell it with elements\n * @param word A single word without spaces\n * @returns false if not possible, or an array of permutations\n */\nfunction processWord(word: string): string[][] | false {\n  word = word.toLowerCase();\n  \n  // Dynamic programming approach to find all possible ways to split the word\n  const dp: boolean[] = new Array(word.length + 1).fill(false);\n  dp[0] = true; // Empty string can always be formed\n  \n  // To store all possible decompositions\n  // elementPathsAt[i] contains all possible ways to decompose word[0...i-1]\n  const elementPathsAt: string[][][] = new Array(word.length + 1);\n  elementPathsAt[0] = [[]]; // Empty path for position 0\n  \n  for (let i = 1; i <= word.length; i++) {\n    elementPathsAt[i] = [];\n    \n    // Try to form word[0...i-1] using element symbols\n    for (let j = 1; j <= Math.min(i, 2); j++) {  // Element symbols are at most 2 characters\n      const symbol = word.substring(i - j, i);\n      \n      if (dp[i - j] && elementSetLower.has(symbol)) {\n        dp[i] = true;\n        \n        // For each path that leads to position (i-j), append this symbol\n        for (const path of elementPathsAt[i - j]) {\n          elementPathsAt[i].push([...path, elementMap[symbol]]);\n        }\n      }\n    }\n  }\n  \n  return dp[word.length] ? elementPathsAt[word.length] : false;\n}\n\n/**\n * Combines permutations from multiple words, adding a space marker between words\n * @param wordPermutations Array of permutations for each word\n * @returns Combined permutations with space markers\n */\nfunction combineWordPermutations(wordPermutations: string[][][]): string[][] {\n  // Start with first word's permutations\n  let result = wordPermutations[0];\n  \n  // Combine with each subsequent word\n  for (let i = 1; i < wordPermutations.length; i++) {\n    const newResult: string[][] = [];\n    \n    // For each existing permutation...\n    for (const existingPath of result) {\n      // ...combine with each permutation of the current word\n      for (const newPath of wordPermutations[i]) {\n        // Add space marker between words\n        newResult.push([...existingPath, '_SPACE_', ...newPath]);\n      }\n    }\n    \n    result = newResult;\n  }\n  \n  return result;\n}\n", "// Element word visualizer application\nimport { canBeSpelledWithElements } from './element-utils';\n\n// Function to modify SVG content to make it responsive and theme-aware\nfunction makeSvgResponsive(svgContent: string): string {\n    return svgContent\n        .replace(/<rect([^>]*)fill=\"white\"/, '<rect$1fill=\"var(--bg-color)\"')\n        .replace(/<text([^>]*?)>([^<]*)<\\/text>/g, '<text$1 fill=\"var(--text-color)\">$2</text>')\n        .replace(/<svg([^>]*)/, '<svg$1 class=\"element-svg-content\"')\n        .replace(/stroke=\"black\"/g, 'stroke=\"var(--text-color)\"');\n}\n\n// Theme management\nfunction setTheme(theme: 'light' | 'dark'): void {\n    if (theme === 'dark') {\n        document.body.classList.add('dark-mode');\n    } else {\n        document.body.classList.remove('dark-mode');\n    }\n}\n\n// Initialize the application\ndocument.addEventListener('DOMContentLoaded', () => {\n    const form = document.getElementById('word-form') as HTMLFormElement;\n    const wordInput = document.getElementById('word-input') as HTMLInputElement;\n    const resultDiv = document.getElementById('result') as HTMLDivElement;\n    const elementContainer = document.getElementById('element-container') as HTMLDivElement;\n    const themeRadios = document.querySelectorAll('input[name=\"theme\"]') as NodeListOf<HTMLInputElement>;\n    \n    // Set up theme toggle event listeners\n    themeRadios.forEach(radio => {\n        radio.addEventListener('change', (e) => {\n            const target = e.target as HTMLInputElement;\n            setTheme(target.value as 'light' | 'dark');\n        });\n    });\n    \n    // Prevent default form submission but still keep the form for accessibility\n    form.addEventListener('submit', (e) => {\n        e.preventDefault();\n    });\n    \n    // Process input as user types\n    wordInput.addEventListener('input', () => {\n        const inputText = wordInput.value.trim();\n        \n        // Clear previous results\n        elementContainer.innerHTML = '';\n        resultDiv.textContent = '';\n        \n        if (!inputText) {\n            resultDiv.textContent = 'Please enter a word or phrase';\n            return;\n        }\n        \n        // Check if the word/phrase can be spelled using element symbols\n        const elementPermutations = canBeSpelledWithElements(inputText);\n        \n        if (elementPermutations && elementPermutations.length > 0) {\n            // Word/phrase can be spelled with element symbols\n            resultDiv.textContent = `\"${inputText}\" can be spelled in ${elementPermutations.length} different way${elementPermutations.length > 1 ? 's' : ''}`;\n            \n            // Create a map to cache SVGs so we don't reload them for each permutation\n            const svgCache: Record<string, string> = {};\n            \n            // Process each permutation\n            elementPermutations.forEach((elementPath, permutationIndex) => {\n                // Create a container for this permutation\n                const permutationRow = document.createElement('div');\n                permutationRow.className = 'permutation-row';\n                \n                elementContainer.appendChild(permutationRow);\n                \n                // Define the result type to handle different cases\n                type ElementResult = \n                    | { element: string; isSpace: true; }\n                    | { element: string; svgContent: string; }\n                    | { element: string; error: true; };\n                    \n                // Array to store promises for this permutation's SVG loads\n                const loadPromises = elementPath.map(element => {\n                    // Skip processing for space markers - will be handled later\n                    if (element === '_SPACE_') {\n                        return Promise.resolve({\n                            element: '_SPACE_',\n                            isSpace: true as const\n                        });\n                    }\n                    \n                    // Use cached SVG if available\n                    if (svgCache[element]) {\n                        return Promise.resolve({\n                            element,\n                            svgContent: svgCache[element]\n                        });\n                    }\n                    \n                    // Otherwise, fetch the SVG\n                    return fetch(`./elements/${element.toLowerCase()}.svg`)\n                        .then(response => {\n                            if (!response.ok) {\n                                throw new Error(`SVG for ${element} not found`);\n                            }\n                            return response.text();\n                        })\n                        .then(svgContent => {\n                            // Cache the SVG\n                            svgCache[element] = svgContent;\n                            return {\n                                element,\n                                svgContent\n                            };\n                        })\n                        .catch(error => {\n                            console.error(error);\n                            return {\n                                element,\n                                error: true as const\n                            };\n                        });\n                });\n                \n                // When all SVGs for this permutation are loaded, add them to the container in the correct order\n                Promise.all(loadPromises)\n                    .then((results: ElementResult[]) => {\n                        results.forEach(result => {\n                            // Handle space marker\n                            if ('isSpace' in result && result.isSpace) {\n                                const spacerDiv = document.createElement('div');\n                                spacerDiv.className = 'word-spacer';\n                                permutationRow.appendChild(spacerDiv);\n                                return;\n                            }\n                            \n                            const elementDiv = document.createElement('div');\n                            elementDiv.className = 'element-svg';\n                            \n                            if ('error' in result && result.error) {\n                                elementDiv.textContent = `Error loading ${result.element}`;\n                            } else if ('svgContent' in result) {\n                                // Make SVG responsive\n                                elementDiv.innerHTML = makeSvgResponsive(result.svgContent);\n                            }\n                            \n                            permutationRow.appendChild(elementDiv);\n                        });\n                    });\n            });\n        } else {\n            // Word/phrase cannot be spelled with element symbols\n            resultDiv.textContent = `\"${inputText}\" cannot be spelled using only chemical elements`;\n        }\n    });\n});\n"],
  "mappings": ";AAGA,IAAM,WAAqB;AAAA,EACzB;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAAK;AAAA,EAChD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EACnD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACrD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EACrD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACtD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACrD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACtD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACrD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACtD;AAAA,EAAM;AAAA,EAAK;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACrD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EACtD;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAAA,EAAM;AAClD;AAGA,IAAM,kBAA+B,IAAI,IAAI,SAAS,IAAI,OAAK,EAAE,YAAY,CAAC,CAAC;AAG/E,IAAM,aAAsC,CAAC;AAC7C,SAAS,QAAQ,OAAK;AACpB,aAAW,EAAE,YAAY,CAAC,IAAI;AAChC,CAAC;AAOM,SAAS,yBAAyB,cAA0C;AAEjF,QAAM,QAAQ,aAAa,MAAM,GAAG,EAAE,OAAO,UAAQ,KAAK,SAAS,CAAC;AACpE,MAAI,MAAM,WAAW,EAAG,QAAO;AAG/B,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,YAAY,MAAM,CAAC,CAAC;AAAA,EAC7B;AAGA,QAAM,mBAAiC,CAAC;AACxC,aAAW,QAAQ,OAAO;AACxB,UAAM,eAAe,YAAY,IAAI;AACrC,QAAI,CAAC,aAAc,QAAO;AAC1B,qBAAiB,KAAK,YAAY;AAAA,EACpC;AAGA,SAAO,wBAAwB,gBAAgB;AACjD;AAOA,SAAS,YAAY,MAAkC;AACrD,SAAO,KAAK,YAAY;AAGxB,QAAM,KAAgB,IAAI,MAAM,KAAK,SAAS,CAAC,EAAE,KAAK,KAAK;AAC3D,KAAG,CAAC,IAAI;AAIR,QAAM,iBAA+B,IAAI,MAAM,KAAK,SAAS,CAAC;AAC9D,iBAAe,CAAC,IAAI,CAAC,CAAC,CAAC;AAEvB,WAAS,IAAI,GAAG,KAAK,KAAK,QAAQ,KAAK;AACrC,mBAAe,CAAC,IAAI,CAAC;AAGrB,aAAS,IAAI,GAAG,KAAK,KAAK,IAAI,GAAG,CAAC,GAAG,KAAK;AACxC,YAAM,SAAS,KAAK,UAAU,IAAI,GAAG,CAAC;AAEtC,UAAI,GAAG,IAAI,CAAC,KAAK,gBAAgB,IAAI,MAAM,GAAG;AAC5C,WAAG,CAAC,IAAI;AAGR,mBAAW,QAAQ,eAAe,IAAI,CAAC,GAAG;AACxC,yBAAe,CAAC,EAAE,KAAK,CAAC,GAAG,MAAM,WAAW,MAAM,CAAC,CAAC;AAAA,QACtD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,SAAO,GAAG,KAAK,MAAM,IAAI,eAAe,KAAK,MAAM,IAAI;AACzD;AAOA,SAAS,wBAAwB,kBAA4C;AAE3E,MAAI,SAAS,iBAAiB,CAAC;AAG/B,WAAS,IAAI,GAAG,IAAI,iBAAiB,QAAQ,KAAK;AAChD,UAAM,YAAwB,CAAC;AAG/B,eAAW,gBAAgB,QAAQ;AAEjC,iBAAW,WAAW,iBAAiB,CAAC,GAAG;AAEzC,kBAAU,KAAK,CAAC,GAAG,cAAc,WAAW,GAAG,OAAO,CAAC;AAAA,MACzD;AAAA,IACF;AAEA,aAAS;AAAA,EACX;AAEA,SAAO;AACT;;;AClHA,SAAS,kBAAkB,YAA4B;AACnD,SAAO,WACF,QAAQ,4BAA4B,+BAA+B,EACnE,QAAQ,kCAAkC,4CAA4C,EACtF,QAAQ,eAAe,oCAAoC,EAC3D,QAAQ,mBAAmB,4BAA4B;AAChE;AAGA,SAAS,SAAS,OAA+B;AAC7C,MAAI,UAAU,QAAQ;AAClB,aAAS,KAAK,UAAU,IAAI,WAAW;AAAA,EAC3C,OAAO;AACH,aAAS,KAAK,UAAU,OAAO,WAAW;AAAA,EAC9C;AACJ;AAGA,SAAS,iBAAiB,oBAAoB,MAAM;AAChD,QAAM,OAAO,SAAS,eAAe,WAAW;AAChD,QAAM,YAAY,SAAS,eAAe,YAAY;AACtD,QAAM,YAAY,SAAS,eAAe,QAAQ;AAClD,QAAM,mBAAmB,SAAS,eAAe,mBAAmB;AACpE,QAAM,cAAc,SAAS,iBAAiB,qBAAqB;AAGnE,cAAY,QAAQ,WAAS;AACzB,UAAM,iBAAiB,UAAU,CAAC,MAAM;AACpC,YAAM,SAAS,EAAE;AACjB,eAAS,OAAO,KAAyB;AAAA,IAC7C,CAAC;AAAA,EACL,CAAC;AAGD,OAAK,iBAAiB,UAAU,CAAC,MAAM;AACnC,MAAE,eAAe;AAAA,EACrB,CAAC;AAGD,YAAU,iBAAiB,SAAS,MAAM;AACtC,UAAM,YAAY,UAAU,MAAM,KAAK;AAGvC,qBAAiB,YAAY;AAC7B,cAAU,cAAc;AAExB,QAAI,CAAC,WAAW;AACZ,gBAAU,cAAc;AACxB;AAAA,IACJ;AAGA,UAAM,sBAAsB,yBAAyB,SAAS;AAE9D,QAAI,uBAAuB,oBAAoB,SAAS,GAAG;AAEvD,gBAAU,cAAc,IAAI,SAAS,uBAAuB,oBAAoB,MAAM,iBAAiB,oBAAoB,SAAS,IAAI,MAAM,EAAE;AAGhJ,YAAM,WAAmC,CAAC;AAG1C,0BAAoB,QAAQ,CAAC,aAAa,qBAAqB;AAE3D,cAAM,iBAAiB,SAAS,cAAc,KAAK;AACnD,uBAAe,YAAY;AAE3B,yBAAiB,YAAY,cAAc;AAS3C,cAAM,eAAe,YAAY,IAAI,aAAW;AAE5C,cAAI,YAAY,WAAW;AACvB,mBAAO,QAAQ,QAAQ;AAAA,cACnB,SAAS;AAAA,cACT,SAAS;AAAA,YACb,CAAC;AAAA,UACL;AAGA,cAAI,SAAS,OAAO,GAAG;AACnB,mBAAO,QAAQ,QAAQ;AAAA,cACnB;AAAA,cACA,YAAY,SAAS,OAAO;AAAA,YAChC,CAAC;AAAA,UACL;AAGA,iBAAO,MAAM,cAAc,QAAQ,YAAY,CAAC,MAAM,EACjD,KAAK,cAAY;AACd,gBAAI,CAAC,SAAS,IAAI;AACd,oBAAM,IAAI,MAAM,WAAW,OAAO,YAAY;AAAA,YAClD;AACA,mBAAO,SAAS,KAAK;AAAA,UACzB,CAAC,EACA,KAAK,gBAAc;AAEhB,qBAAS,OAAO,IAAI;AACpB,mBAAO;AAAA,cACH;AAAA,cACA;AAAA,YACJ;AAAA,UACJ,CAAC,EACA,MAAM,WAAS;AACZ,oBAAQ,MAAM,KAAK;AACnB,mBAAO;AAAA,cACH;AAAA,cACA,OAAO;AAAA,YACX;AAAA,UACJ,CAAC;AAAA,QACT,CAAC;AAGD,gBAAQ,IAAI,YAAY,EACnB,KAAK,CAAC,YAA6B;AAChC,kBAAQ,QAAQ,YAAU;AAEtB,gBAAI,aAAa,UAAU,OAAO,SAAS;AACvC,oBAAM,YAAY,SAAS,cAAc,KAAK;AAC9C,wBAAU,YAAY;AACtB,6BAAe,YAAY,SAAS;AACpC;AAAA,YACJ;AAEA,kBAAM,aAAa,SAAS,cAAc,KAAK;AAC/C,uBAAW,YAAY;AAEvB,gBAAI,WAAW,UAAU,OAAO,OAAO;AACnC,yBAAW,cAAc,iBAAiB,OAAO,OAAO;AAAA,YAC5D,WAAW,gBAAgB,QAAQ;AAE/B,yBAAW,YAAY,kBAAkB,OAAO,UAAU;AAAA,YAC9D;AAEA,2BAAe,YAAY,UAAU;AAAA,UACzC,CAAC;AAAA,QACL,CAAC;AAAA,MACT,CAAC;AAAA,IACL,OAAO;AAEH,gBAAU,cAAc,IAAI,SAAS;AAAA,IACzC;AAAA,EACJ,CAAC;AACL,CAAC;",
  "names": []
}

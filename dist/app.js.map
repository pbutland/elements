{
  "version": 3,
  "sources": ["../src/element-types.ts", "../src/element-utils.ts", "../src/app.ts"],
  "sourcesContent": ["// Element type definitions and color schemes for styling element symbols\n// Each element is categorized according to standard periodic table groupings\n// Colors use a pastel palette with darker borders\n\n// Define element types as an enum for better type safety\nexport enum ElementType {\n    ALKALI_METAL = 'Alkali Metal',\n    ALKALINE_EARTH = 'Alkaline Earth',\n    TRANSITION_METAL = 'Transition Metal',\n    BASIC_METAL = 'Basic Metal',\n    METALLOID = 'Metalloid',\n    NONMETAL = 'Nonmetal',\n    HALOGEN = 'Halogen',\n    NOBLE_GAS = 'Noble Gas',\n    LANTHANIDE = 'Lanthanide',\n    ACTINIDE = 'Actinide',\n    OTHER = 'Other',\n    UNKNOWN = 'Unknown'\n}\n\n/**\n * Creates a darker shade of a given hexadecimal color\n * @param color The hexadecimal color to darken (e.g. '#RRGGBB')\n * @param percent The percentage to darken the color (0-100)\n * @returns A darker hexadecimal color\n */\nexport function darkenColor(color: string, percent: number = 20): string {\n    // Remove the hash if it exists\n    color = color.replace('#', '');\n    \n    // Parse the hex values\n    const r = parseInt(color.substring(0, 2), 16);\n    const g = parseInt(color.substring(2, 4), 16);\n    const b = parseInt(color.substring(4, 6), 16);\n    \n    // Calculate the darker shade by reducing the RGB values\n    const darkenAmount = 1 - (percent / 100);\n    const dr = Math.max(0, Math.floor(r * darkenAmount));\n    const dg = Math.max(0, Math.floor(g * darkenAmount));\n    const db = Math.max(0, Math.floor(b * darkenAmount));\n    \n    // Convert back to hex\n    return `#${dr.toString(16).padStart(2, '0')}${dg.toString(16).padStart(2, '0')}${db.toString(16).padStart(2, '0')}`;\n}\n\n// Map element types to their base colors\nexport const elementTypeColors: Record<ElementType, string> = {\n    [ElementType.ALKALI_METAL]: '#FFCDD2',\n    [ElementType.ALKALINE_EARTH]: '#FFECB3',\n    [ElementType.TRANSITION_METAL]: '#C8E6C9',\n    [ElementType.BASIC_METAL]: '#B3E5FC',\n    [ElementType.METALLOID]: '#E1BEE7',\n    [ElementType.NONMETAL]: '#FDECEB',\n    [ElementType.HALOGEN]: '#D1C4E9',\n    [ElementType.NOBLE_GAS]: '#BBDEFB',\n    [ElementType.LANTHANIDE]: '#FFE0B2',\n    [ElementType.ACTINIDE]: '#F8BBD0',\n    [ElementType.OTHER]: '#E0E0E0',\n    [ElementType.UNKNOWN]: '#E0E0E0'\n};\n\n// Map element symbols to their types\nexport const elementToTypeMap: Record<string, ElementType> = {\n    // Alkali Metals\n    'H': ElementType.NONMETAL,\n    'Li': ElementType.ALKALI_METAL,\n    'Na': ElementType.ALKALI_METAL,\n    'K': ElementType.ALKALI_METAL,\n    'Rb': ElementType.ALKALI_METAL,\n    'Cs': ElementType.ALKALI_METAL,\n    'Fr': ElementType.ALKALI_METAL,\n    \n    // Alkaline Earth Metals\n    'Be': ElementType.ALKALINE_EARTH,\n    'Mg': ElementType.ALKALINE_EARTH,\n    'Ca': ElementType.ALKALINE_EARTH,\n    'Sr': ElementType.ALKALINE_EARTH,\n    'Ba': ElementType.ALKALINE_EARTH,\n    'Ra': ElementType.ALKALINE_EARTH,\n    \n    // Transition Metals\n    'Sc': ElementType.TRANSITION_METAL,\n    'Ti': ElementType.TRANSITION_METAL,\n    'V': ElementType.TRANSITION_METAL,\n    'Cr': ElementType.TRANSITION_METAL,\n    'Mn': ElementType.TRANSITION_METAL,\n    'Fe': ElementType.TRANSITION_METAL,\n    'Co': ElementType.TRANSITION_METAL,\n    'Ni': ElementType.TRANSITION_METAL,\n    'Cu': ElementType.TRANSITION_METAL,\n    'Zn': ElementType.TRANSITION_METAL,\n    'Y': ElementType.TRANSITION_METAL,\n    'Zr': ElementType.TRANSITION_METAL,\n    'Nb': ElementType.TRANSITION_METAL,\n    'Mo': ElementType.TRANSITION_METAL,\n    'Tc': ElementType.TRANSITION_METAL,\n    'Ru': ElementType.TRANSITION_METAL,\n    'Rh': ElementType.TRANSITION_METAL,\n    'Pd': ElementType.TRANSITION_METAL,\n    'Ag': ElementType.TRANSITION_METAL,\n    'Cd': ElementType.TRANSITION_METAL,\n    'Hf': ElementType.TRANSITION_METAL,\n    'Ta': ElementType.TRANSITION_METAL,\n    'W': ElementType.TRANSITION_METAL,\n    'Re': ElementType.TRANSITION_METAL,\n    'Os': ElementType.TRANSITION_METAL,\n    'Ir': ElementType.TRANSITION_METAL,\n    'Pt': ElementType.TRANSITION_METAL,\n    'Au': ElementType.TRANSITION_METAL,\n    'Hg': ElementType.TRANSITION_METAL,\n    'Rf': ElementType.TRANSITION_METAL,\n    'Db': ElementType.TRANSITION_METAL,\n    'Sg': ElementType.TRANSITION_METAL,\n    'Bh': ElementType.TRANSITION_METAL,\n    'Hs': ElementType.TRANSITION_METAL,\n    'Mt': ElementType.TRANSITION_METAL,\n    'Ds': ElementType.TRANSITION_METAL,\n    'Rg': ElementType.TRANSITION_METAL,\n    \n    // Basic Metals (Post-Transition Metals)\n    'Al': ElementType.BASIC_METAL,\n    'Ga': ElementType.BASIC_METAL,\n    'In': ElementType.BASIC_METAL,\n    'Sn': ElementType.BASIC_METAL,\n    'Tl': ElementType.BASIC_METAL,\n    'Pb': ElementType.BASIC_METAL,\n    'Bi': ElementType.BASIC_METAL,\n    'Po': ElementType.BASIC_METAL,\n    'Cn': ElementType.BASIC_METAL,\n    'Nh': ElementType.BASIC_METAL,\n    'Fl': ElementType.BASIC_METAL,\n    'Mc': ElementType.BASIC_METAL,\n    'Lv': ElementType.BASIC_METAL,\n    \n    // Metalloids\n    'B': ElementType.METALLOID,\n    'Si': ElementType.METALLOID,\n    'Ge': ElementType.METALLOID,\n    'As': ElementType.METALLOID,\n    'Sb': ElementType.METALLOID,\n    'Te': ElementType.METALLOID,\n    'At': ElementType.METALLOID,\n    \n    // Nonmetals\n    'C': ElementType.NONMETAL,\n    'N': ElementType.NONMETAL,\n    'O': ElementType.NONMETAL,\n    'P': ElementType.NONMETAL,\n    'S': ElementType.NONMETAL,\n    'Se': ElementType.NONMETAL,\n    \n    // Halogens\n    'F': ElementType.HALOGEN,\n    'Cl': ElementType.HALOGEN,\n    'Br': ElementType.HALOGEN,\n    'I': ElementType.HALOGEN,\n    'Ts': ElementType.HALOGEN,\n    \n    // Noble Gases\n    'He': ElementType.NOBLE_GAS,\n    'Ne': ElementType.NOBLE_GAS,\n    'Ar': ElementType.NOBLE_GAS,\n    'Kr': ElementType.NOBLE_GAS,\n    'Xe': ElementType.NOBLE_GAS,\n    'Rn': ElementType.NOBLE_GAS,\n    'Og': ElementType.NOBLE_GAS,\n    \n    // Lanthanides\n    'La': ElementType.LANTHANIDE,\n    'Ce': ElementType.LANTHANIDE,\n    'Pr': ElementType.LANTHANIDE,\n    'Nd': ElementType.LANTHANIDE,\n    'Pm': ElementType.LANTHANIDE,\n    'Sm': ElementType.LANTHANIDE,\n    'Eu': ElementType.LANTHANIDE,\n    'Gd': ElementType.LANTHANIDE,\n    'Tb': ElementType.LANTHANIDE,\n    'Dy': ElementType.LANTHANIDE,\n    'Ho': ElementType.LANTHANIDE,\n    'Er': ElementType.LANTHANIDE,\n    'Tm': ElementType.LANTHANIDE,\n    'Yb': ElementType.LANTHANIDE,\n    'Lu': ElementType.LANTHANIDE,\n    \n    // Actinides\n    'Ac': ElementType.ACTINIDE,\n    'Th': ElementType.ACTINIDE,\n    'Pa': ElementType.ACTINIDE,\n    'U': ElementType.ACTINIDE,\n    'Np': ElementType.ACTINIDE,\n    'Pu': ElementType.ACTINIDE,\n    'Am': ElementType.ACTINIDE,\n    'Cm': ElementType.ACTINIDE,\n    'Bk': ElementType.ACTINIDE,\n    'Cf': ElementType.ACTINIDE,\n    'Es': ElementType.ACTINIDE,\n    'Fm': ElementType.ACTINIDE,\n    'Md': ElementType.ACTINIDE,\n    'No': ElementType.ACTINIDE,\n    'Lr': ElementType.ACTINIDE,\n    \n    // Other elements/placeholders\n    'E': ElementType.OTHER\n};\n\n// Interface for element type info (for backwards compatibility)\nexport interface ElementTypeInfo {\n    type: string;\n    backgroundColor: string;\n    borderColor: string;\n}\n\n/**\n * Gets element type information for a given element symbol.\n * \n * @param element The element symbol (case-insensitive)\n * @returns ElementTypeInfo containing type name and color information\n */\nexport function getElementTypeInfo(element: string): ElementTypeInfo {\n    // Normalize element symbol (capitalize first letter, lowercase the rest)\n    const normalizedElement = element.charAt(0).toUpperCase() + element.slice(1).toLowerCase();\n    \n    // Get the element type or use UNKNOWN as fallback\n    const elementType = elementToTypeMap[normalizedElement] || ElementType.UNKNOWN;\n    \n    // Get the base color for this element type\n    const baseColor = elementTypeColors[elementType];\n    \n    // Generate a darker border color from the base color\n    const borderColor = darkenColor(baseColor, 25);\n    \n    // Return in the ElementTypeInfo format for backwards compatibility\n    return { \n        type: elementType,\n        backgroundColor: baseColor,\n        borderColor: borderColor\n    };\n}\n", "// Element utilities for checking if words can be spelled with element symbols\nimport { elementToTypeMap } from './element-types';\n\n// Get all valid element symbols from the elementToTypeMap in element-types.ts\nconst elements: string[] = Object.keys(elementToTypeMap);\n\n// Create case-insensitive element set for comparisons\nconst elementSetLower: Set<string> = new Set(elements.map(e => e.toLowerCase()));\n\n// Elements map with correct capitalization for output\nconst elementMap: {[key: string]: string} = {};\nelements.forEach(e => {\n  elementMap[e.toLowerCase()] = e;\n});\n\n/**\n * Check if a word or phrase can be spelled using only element symbols\n * @param wordOrPhrase The word or phrase to check\n * @returns false if not possible, or an array of permutations (each permutation is an array of element symbols with special '_SPACE_' marker for word boundaries)\n */\nexport function canBeSpelledWithElements(wordOrPhrase: string): string[][] | false {\n  // Split the input by spaces to handle multiple words\n  const words = wordOrPhrase.split(' ').filter(word => word.length > 0);\n  if (words.length === 0) return false;\n  \n  // If it's just one word, use the original algorithm\n  if (words.length === 1) {\n    return processWord(words[0]);\n  }\n  \n  // Process each word separately\n  const wordPermutations: string[][][] = [];\n  for (const word of words) {\n    const permutations = processWord(word);\n    if (!permutations) return false; // If any word can't be spelled, the whole phrase can't be spelled\n    wordPermutations.push(permutations);\n  }\n  \n  // Combine permutations from all words with space markers\n  return combineWordPermutations(wordPermutations);\n}\n\n/**\n * Process a single word to find all possible ways to spell it with elements\n * @param word A single word without spaces\n * @returns false if not possible, or an array of permutations\n */\nfunction processWord(word: string): string[][] | false {\n  word = word.toLowerCase();\n  \n  // Dynamic programming approach to find all possible ways to split the word\n  const dp: boolean[] = new Array(word.length + 1).fill(false);\n  dp[0] = true; // Empty string can always be formed\n  \n  // To store all possible decompositions\n  // elementPathsAt[i] contains all possible ways to decompose word[0...i-1]\n  const elementPathsAt: string[][][] = new Array(word.length + 1);\n  elementPathsAt[0] = [[]]; // Empty path for position 0\n  \n  for (let i = 1; i <= word.length; i++) {\n    elementPathsAt[i] = [];\n    \n    // Try to form word[0...i-1] using element symbols\n    for (let j = 1; j <= Math.min(i, 2); j++) {  // Element symbols are at most 2 characters\n      const symbol = word.substring(i - j, i);\n      \n      if (dp[i - j] && elementSetLower.has(symbol)) {\n        dp[i] = true;\n        \n        // For each path that leads to position (i-j), append this symbol\n        for (const path of elementPathsAt[i - j]) {\n          elementPathsAt[i].push([...path, elementMap[symbol]]);\n        }\n      }\n    }\n  }\n  \n  return dp[word.length] ? elementPathsAt[word.length] : false;\n}\n\n/**\n * Combines permutations from multiple words, adding a space marker between words\n * @param wordPermutations Array of permutations for each word\n * @returns Combined permutations with space markers\n */\nfunction combineWordPermutations(wordPermutations: string[][][]): string[][] {\n  // Start with first word's permutations\n  let result = wordPermutations[0];\n  \n  // Combine with each subsequent word\n  for (let i = 1; i < wordPermutations.length; i++) {\n    const newResult: string[][] = [];\n    \n    // For each existing permutation...\n    for (const existingPath of result) {\n      // ...combine with each permutation of the current word\n      for (const newPath of wordPermutations[i]) {\n        // Add space marker between words\n        newResult.push([...existingPath, '_SPACE_', ...newPath]);\n      }\n    }\n    \n    result = newResult;\n  }\n  \n  return result;\n}\n", "// Element word visualizer application\nimport { canBeSpelledWithElements } from './element-utils';\nimport { getElementTypeInfo, ElementType, elementTypeColors, darkenColor, elementToTypeMap } from './element-types';\n\n// Function to generate the legend dynamically\nfunction generateElementTypeLegend(elementPermutations: string[][] | false = false) {\n    const legendElement = document.getElementById('element-type-legend');\n    if (!legendElement) return;\n\n    const coloredElementsToggle = document.getElementById('colored-elements') as HTMLInputElement;\n    \n    // Only show legend if there are letters in input AND there are valid permutations\n    const shouldShowLegend = elementPermutations && elementPermutations.length > 0 && coloredElementsToggle?.checked;\n    legendElement.style.display = shouldShowLegend ? 'block' : 'none';\n\n    // If we shouldn't show the legend, no need to continue\n    if (!shouldShowLegend) return;\n\n    // Clear existing legend\n    const legendContainer = legendElement.querySelector('.legend-container') as HTMLDivElement;\n    if (!legendContainer) return;\n    \n    legendContainer.innerHTML = '';\n\n    // Get all element types that appear in any permutation\n    const usedElementTypes = new Set<ElementType>();\n    \n    if (elementPermutations && elementPermutations.length > 0) {\n        // Get all unique elements from all permutations\n        const uniqueElements = [...new Set(\n            elementPermutations.flatMap(permutation => \n                permutation.filter(element => element !== '_SPACE_')\n            )\n        )];\n        \n        // Convert to element types - include any element that appears in any permutation\n        uniqueElements.forEach(element => {\n            const elementType = elementToTypeMap[element];\n            if (elementType && elementType !== ElementType.UNKNOWN && elementType !== ElementType.OTHER) {\n                usedElementTypes.add(elementType);\n            }\n        });\n    }\n\n    // Create a legend item for each element type that appears in any permutation\n    Object.entries(ElementType).forEach(([key, typeName]) => {\n        // Skip types that don't appear in any permutation\n        if (!usedElementTypes.has(typeName as ElementType)) return;\n            \n        // Skip UNKNOWN and OTHER types in the legend\n        if (key === 'UNKNOWN' || key === 'OTHER') return;\n\n        // Get the base color for this element type\n        const baseColor = elementTypeColors[typeName as ElementType];\n        if (!baseColor) return;\n\n        // Generate border color programmatically\n        const borderColor = darkenColor(baseColor, 25);\n\n        // Create the legend item\n        const legendItem = document.createElement('div');\n        legendItem.className = 'legend-item';\n\n        // Create the color sample\n        const colorSample = document.createElement('span');\n        colorSample.className = 'legend-color';\n        colorSample.style.backgroundColor = baseColor;\n        colorSample.style.border = `2px solid ${borderColor}`;\n\n        // Add the text label\n        legendItem.appendChild(colorSample);\n        legendItem.appendChild(document.createTextNode(typeName));\n\n        // Add to the legend container\n        legendContainer.appendChild(legendItem);\n    });\n}\n\n// Function to modify SVG content to make it responsive and theme-aware\nfunction makeSvgResponsive(svgContent: string, useColoredElements: boolean = false, elementSymbol: string = ''): string {\n    let modifiedSvg = svgContent;\n    \n    if (useColoredElements && elementSymbol) {\n        // For colored elements mode, apply the element type coloring directly\n        const typeInfo = getElementTypeInfo(elementSymbol);\n        \n        // Apply the background color to the rectangle and border color to the stroke\n        modifiedSvg = modifiedSvg.replace(\n            /<rect([^>]*)fill=\"white\"([^>]*)stroke=\"black\"([^>]*)>/,\n            `<rect$1fill=\"${typeInfo.backgroundColor}\"$2stroke=\"${typeInfo.borderColor}\"$3>`\n        );\n        \n        // Add the SVG content class without modifying text colors\n        modifiedSvg = modifiedSvg.replace(\n            /<svg([^>]*)/,\n            '<svg$1 class=\"element-svg-content\"'\n        );\n    } else {\n        // For normal theme-aware mode (non-colored)\n        modifiedSvg = svgContent\n            .replace(/<rect([^>]*)fill=\"white\"/, '<rect$1fill=\"var(--bg-color)\"')\n            .replace(/<text([^>]*?)>([^<]*)<\\/text>/g, '<text$1 fill=\"var(--text-color)\">$2</text>')\n            .replace(/<svg([^>]*)/, '<svg$1 class=\"element-svg-content\"')\n            .replace(/stroke=\"black\"/g, 'stroke=\"var(--text-color)\"');\n    }\n    \n    return modifiedSvg;\n}\n\n// Function to create a downloadable SVG from a permutation row\nfunction downloadPermutationAsSVG(permutationRow: HTMLElement, word: string, useColoredElements: boolean = false): void {\n    // Get all word containers in the permutation row\n    const wordContainers = permutationRow.querySelectorAll('.element-word');\n    if (!wordContainers.length) return;\n    \n    // Get computed colors from CSS variables for SVG export\n    const computedStyle = getComputedStyle(document.body);\n    const bgColor = computedStyle.getPropertyValue('--bg-color').trim();\n    const textColor = computedStyle.getPropertyValue('--text-color').trim();\n    \n    // Get all SVG elements for validation\n    const allSvgElements = permutationRow.querySelectorAll('.element-svg-content');\n    if (!allSvgElements.length) return;\n    \n    // Helper function to get original SVG dimensions\n    const getOriginalSvgDimensions = (svgElement: SVGSVGElement): { width: number, height: number } => {\n        // Parse the SVG content\n        const svgString = new XMLSerializer().serializeToString(svgElement);\n        const parser = new DOMParser();\n        const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');\n        const originalSvg = svgDoc.documentElement;\n        \n        // Try to get width and height from attributes first\n        let width = parseFloat(originalSvg.getAttribute('width') || '0');\n        let height = parseFloat(originalSvg.getAttribute('height') || '0');\n        \n        // If not available, try to get from viewBox\n        if (width === 0 || height === 0) {\n            const viewBox = originalSvg.getAttribute('viewBox');\n            if (viewBox) {\n                const parts = viewBox.split(/\\s+|,/).map(parseFloat);\n                if (parts.length === 4) {\n                    width = parts[2];\n                    height = parts[3];\n                }\n            }\n        }\n        \n        // Use fallback values if still not available\n        if (width === 0) width = 100;\n        if (height === 0) height = 100;\n        \n        return { width, height };\n    };\n    \n    // Calculate dimensions based on the SVG elements\n    let totalWidth = 0;\n    let maxHeight = 0;\n    let wordCount = 0;\n    \n    // First pass to calculate max height across all elements\n    allSvgElements.forEach((svg: Element) => {\n        const svgElement = svg as SVGSVGElement;\n        const { height } = getOriginalSvgDimensions(svgElement);\n        maxHeight = Math.max(maxHeight, height);\n    });\n    \n    // Calculate total width, considering word grouping\n    wordContainers.forEach((wordContainer) => {\n        const wordSvgElements = wordContainer.querySelectorAll('.element-svg-content');\n        if (wordSvgElements.length > 0) {\n            wordCount++;\n            let wordWidth = 0;\n            \n            // Calculate width for this word\n            wordSvgElements.forEach((svg: Element) => {\n                const svgElement = svg as SVGSVGElement;\n                const { width } = getOriginalSvgDimensions(svgElement);\n                wordWidth += width;\n            });\n            \n            // Add spacing between elements within the word\n            wordWidth += (wordSvgElements.length - 1) * 10;\n            \n            totalWidth += wordWidth;\n        }\n    });\n    \n    // Add some padding\n    totalWidth += 20;  // 10px padding on each side\n    \n    // Add extra spacing between words (20px between words)\n    if (wordCount > 1) {\n        totalWidth += (wordCount - 1) * 20;\n    }\n    \n    // Account for the extra spacing that's added after the last element of each word\n    // When positioning elements, we add extra 10px spacing after every element including the last one\n    // but that space isn't needed for the last element in each word\n    totalWidth += wordCount * 10;\n    \n    maxHeight += 20;   // 10px padding on top and bottom\n    \n    // Start creating the combined SVG\n    const combinedSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n    combinedSvg.setAttribute('width', totalWidth.toString());\n    combinedSvg.setAttribute('height', maxHeight.toString());\n    combinedSvg.setAttribute('viewBox', `0 0 ${totalWidth} ${maxHeight}`);\n    combinedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    \n    // Set background color based on current theme (using actual RGB color instead of variable)\n    const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n    bgRect.setAttribute('width', '100%');\n    bgRect.setAttribute('height', '100%');\n    bgRect.setAttribute('fill', computedStyle.backgroundColor);\n    combinedSvg.appendChild(bgRect);\n    \n    // Group to hold all the elements\n    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n    \n    // Current X position for placing elements\n    let currentX = 10;  // Start with 10px padding\n    \n    // Process each word container and its SVG elements\n    wordContainers.forEach((wordContainer) => {\n        const wordSvgElements = wordContainer.querySelectorAll('.element-svg-content');\n        if (wordSvgElements.length === 0) return;\n        \n        // Create a group for this word\n        const wordGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n        group.appendChild(wordGroup);\n        \n        // Starting X position for elements within this word\n        const wordStartX = currentX;\n        let wordCurrentX = 0;            // Process each SVG element in this word\n        wordSvgElements.forEach((svg: Element) => {\n            const svgElement = svg as SVGSVGElement;\n            const { width, height } = getOriginalSvgDimensions(svgElement);\n            \n            // Get the element symbol from the data attribute\n            const elementSymbol = svgElement.getAttribute('data-element') || '';\n            \n            // Get the original SVG's XML content\n            const svgString = new XMLSerializer().serializeToString(svgElement);\n            \n            // Parse the original SVG content as a document\n            const parser = new DOMParser();\n            const svgDoc = parser.parseFromString(svgString, 'image/svg+xml');\n            const originalSvg = svgDoc.documentElement;\n            \n            // Replace CSS variables with computed values in the SVG content\n            const replaceVarsInElement = (el: Element, elementSymbol: string = '', useColoredElements: boolean = false) => {\n                // For rectangle elements\n                if (el.tagName.toLowerCase() === 'rect') {\n                    if (useColoredElements && elementSymbol) {\n                        // When colored elements are enabled, apply element-specific colors\n                        const { backgroundColor, borderColor } = getElementTypeInfo(elementSymbol);\n                        el.setAttribute('fill', backgroundColor);\n                        el.setAttribute('stroke', borderColor);\n                    } else {\n                        // Standard theme handling\n                        const fillValue = el.getAttribute('fill');\n                        if (fillValue?.includes('var(--bg-color)') || fillValue === 'white') {\n                            el.setAttribute('fill', computedStyle.backgroundColor);\n                        }\n                        \n                        const strokeValue = el.getAttribute('stroke');\n                        if (strokeValue?.includes('var(--text-color)') || strokeValue === 'black') {\n                            el.setAttribute('stroke', computedStyle.color);\n                        }\n                    }\n                }\n                \n                // For text elements - always keep them readable\n                if (el.tagName.toLowerCase() === 'text') {\n                    // In colored mode, text stays black (default)\n                    // In theme mode, apply the text color from the theme\n                    if (!useColoredElements && el.hasAttribute('fill')) {\n                        const fillValue = el.getAttribute('fill');\n                        if (fillValue?.includes('var(--text-color)')) {\n                            el.setAttribute('fill', computedStyle.color);\n                        }\n                    }\n                }\n                \n                // Handle any other elements with stroke attributes\n                if (!useColoredElements && el.hasAttribute('stroke') && el.tagName.toLowerCase() !== 'rect') {\n                    const strokeValue = el.getAttribute('stroke');\n                    if (strokeValue?.includes('var(--text-color)') || strokeValue === 'black') {\n                        el.setAttribute('stroke', computedStyle.color);\n                    }\n                }\n                \n                // Process children recursively\n                Array.from(el.children).forEach(child => {\n                    replaceVarsInElement(child, elementSymbol, useColoredElements);\n                });\n            };\n            \n            // Extract content from original SVG directly\n            // Most element SVGs have their content in a g tag\n            let contentElement = originalSvg.querySelector('g');\n            \n            // Element position within the word group\n            const elementX = wordStartX + wordCurrentX;\n            \n            if (contentElement) {\n                // Clone the content element\n                const clonedContent = contentElement.cloneNode(true) as Element;\n                \n                // Apply necessary transformations to position the element\n                const currentTransform = clonedContent.getAttribute('transform') || '';\n                clonedContent.setAttribute('transform', \n                    `translate(${elementX}, ${(maxHeight - height) / 2}) ${currentTransform}`);\n                \n                // Replace variables\n                replaceVarsInElement(clonedContent, elementSymbol, useColoredElements);\n                \n                // Add to the word group\n                wordGroup.appendChild(clonedContent);\n            } else {\n                // If no g tag found, create a group for this element\n                const newGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\n                newGroup.setAttribute('transform', `translate(${elementX}, ${(maxHeight - height) / 2})`);\n                \n                // Copy all child nodes except the svg tag itself\n                Array.from(originalSvg.childNodes).forEach(child => {\n                    if (child.nodeType === Node.ELEMENT_NODE && (child as Element).tagName.toLowerCase() !== 'svg') {\n                        const importedNode = document.importNode(child, true);\n                        if (importedNode.nodeType === Node.ELEMENT_NODE) {\n                            replaceVarsInElement(importedNode as Element, elementSymbol, useColoredElements);\n                        }\n                        newGroup.appendChild(importedNode);\n                    }\n                });\n                \n                // Add to the word group\n                wordGroup.appendChild(newGroup);\n            }\n            \n            wordCurrentX += width + 10;  // Add spacing between elements within the word\n        });\n        \n        // Move to the next word's starting position (with extra spacing between words)\n        currentX += wordCurrentX + 20;  // Add extra space (20px) between words\n    });\n    \n    combinedSvg.appendChild(group);\n    \n    // Convert SVG to a data URI\n    const svgData = new XMLSerializer().serializeToString(combinedSvg);\n    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });\n    const svgUrl = URL.createObjectURL(svgBlob);\n    \n    // Create a download link\n    const downloadLink = document.createElement('a');\n    downloadLink.href = svgUrl;\n    downloadLink.download = `${word.replace(/\\s+/g, '-')}-elements.svg`;\n    \n    // Trigger download\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n    \n    // Clean up the URL object\n    setTimeout(() => {\n        URL.revokeObjectURL(svgUrl);\n    }, 100);\n}\n\n// Function to create a shareable URL and copy to clipboard\nfunction shareUrl(word: string): void {\n    // Create URL with the current word as a parameter\n    const url = new URL(window.location.href);\n    url.search = new URLSearchParams({ word }).toString();\n    \n    // Copy to clipboard\n    navigator.clipboard.writeText(url.toString())\n        .then(() => {\n            // Show toast notification\n            const toast = document.getElementById('toast');\n            if (toast) {\n                toast.classList.add('show');\n                \n                // Hide toast after 3 seconds\n                setTimeout(() => {\n                    toast.classList.remove('show');\n                }, 3000);\n            }\n        })\n        .catch(err => {\n            console.error('Failed to copy URL: ', err);\n            alert('Failed to copy the share link to clipboard.');\n        });\n}\n\n// Theme management\nfunction setTheme(theme: 'light' | 'dark'): void {\n    if (theme === 'dark') {\n        document.body.classList.add('dark-mode');\n    } else {\n        document.body.classList.remove('dark-mode');\n    }\n}\n\n// Function to get URL query parameters\nfunction getQueryParam(param: string): string | null {\n    const urlParams = new URLSearchParams(window.location.search);\n    return urlParams.get(param);\n}\n\n// Function to process word input\nfunction processWordInput(word: string, elementContainer: HTMLElement, resultDiv: HTMLElement, useColoredElements: boolean = false): void {\n    // Clear previous results\n    elementContainer.innerHTML = '';\n    resultDiv.textContent = '';\n\n    // Get share button\n    const shareButton = document.getElementById('share-button') as HTMLButtonElement;\n    \n    // Disable the share button by default\n    if (shareButton) {\n        shareButton.disabled = true;\n    }\n    \n    if (!word) {\n        // If no word, make sure the legend is hidden\n        generateElementTypeLegend();\n        return;\n    }\n    \n    // Check if the word/phrase can be spelled using element symbols\n    const elementPermutations = canBeSpelledWithElements(word);\n    \n    // Update the legend with element permutations\n    generateElementTypeLegend(elementPermutations);\n    \n    if (elementPermutations && elementPermutations.length > 0) {\n        // Word/phrase can be spelled with element symbols\n        resultDiv.textContent = elementPermutations.length > 1 ? `\"${word}\" can be spelled in ${elementPermutations.length} different way${elementPermutations.length > 1 ? 's' : ''}` : ``;\n        \n        // Enable the share button if the word can be spelled\n        if (shareButton) {\n            shareButton.disabled = false;\n        }\n        \n        // Create a map to cache SVGs so we don't reload them for each permutation\n        const svgCache: Record<string, string> = {};\n        \n        // Process each permutation\n        elementPermutations.forEach((elementPath, permutationIndex) => {\n            // Create a container for this permutation\n            const permutationRow = document.createElement('div');\n            permutationRow.className = 'permutation-row';\n            \n            elementContainer.appendChild(permutationRow);\n            \n            // Define the result type to handle different cases\n            type ElementResult = \n                | { element: string; isSpace: true; }\n                | { element: string; svgContent: string; }\n                | { element: string; error: true; };\n                \n            // Array to store promises for this permutation's SVG loads\n            const loadPromises = elementPath.map(element => {\n                // Skip processing for space markers - will be handled later\n                if (element === '_SPACE_') {\n                    return Promise.resolve({\n                        element: '_SPACE_',\n                        isSpace: true as const\n                    });\n                }\n                \n                // Use cached SVG if available\n                if (svgCache[element]) {\n                    return Promise.resolve({\n                        element,\n                        svgContent: svgCache[element]\n                    });\n                }\n                \n                // Otherwise, fetch the SVG\n                return fetch(`./elements/${element.toLowerCase()}.svg`)\n                    .then(response => {\n                        if (!response.ok) {\n                            throw new Error(`SVG for ${element} not found`);\n                        }\n                        return response.text();\n                    })\n                    .then(svgContent => {\n                        // Cache the SVG\n                        svgCache[element] = svgContent;\n                        return {\n                            element,\n                            svgContent\n                        };\n                    })\n                    .catch(error => {\n                        console.error(error);\n                        return {\n                            element,\n                            error: true as const\n                        };\n                    });\n            });\n            \n            // When all SVGs for this permutation are loaded, add them to the container in the correct order\n            Promise.all(loadPromises)\n                .then((results: ElementResult[]) => {\n                    // Group elements into words\n                    let currentWord = document.createElement('div');\n                    currentWord.className = 'element-word';\n                    permutationRow.appendChild(currentWord);\n                    \n                    results.forEach(result => {\n                        // Handle space marker - create a new word container\n                        if ('isSpace' in result && result.isSpace) {\n                            currentWord = document.createElement('div');\n                            currentWord.className = 'element-word';\n                            permutationRow.appendChild(currentWord);\n                            return;\n                        }\n                        \n                        const elementDiv = document.createElement('div');\n                        elementDiv.className = 'element-svg';\n                        \n                        if ('error' in result && result.error) {\n                            elementDiv.textContent = `Error loading ${result.element}`;\n                        } else if ('svgContent' in result) {\n                            // Make SVG responsive - pass the element symbol and the colored option to apply correct colors\n                            elementDiv.innerHTML = makeSvgResponsive(result.svgContent, useColoredElements, result.element);\n                            \n                            // Store the element symbol as a data attribute for download SVG function\n                            const svgElement = elementDiv.querySelector('.element-svg-content');\n                            if (svgElement) {\n                                svgElement.setAttribute('data-element', result.element);\n                            }\n                        }\n                        \n                        // Add the element to the current word container\n                        currentWord.appendChild(elementDiv);\n                    });\n                    \n                    // Add download button for this permutation\n                    const downloadButton = document.createElement('button');\n                    downloadButton.className = 'download-svg-button';\n                    downloadButton.title = 'Download SVG';\n                    downloadButton.innerHTML = `\n                        <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"20\" height=\"20\" fill=\"currentColor\" viewBox=\"0 0 16 16\">\n                            <path d=\"M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z\"/>\n                            <path d=\"M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708l3 3z\"/>\n                        </svg>\n                    `;\n                    permutationRow.appendChild(downloadButton);\n                    \n                    // Set up download button click handler\n                    downloadButton.addEventListener('click', () => {\n                        downloadPermutationAsSVG(permutationRow, word, useColoredElements);\n                    });\n                });\n        });\n    } else {\n        // Word/phrase cannot be spelled with element symbols\n        resultDiv.textContent = `\"${word}\" cannot be spelled using only chemical elements`;\n        \n        // Keep share button disabled since the word can't be spelled\n        if (shareButton) {\n            shareButton.disabled = true;\n        }\n    }\n}\n\n// Initialize the application\ndocument.addEventListener('DOMContentLoaded', () => {\n    const form = document.getElementById('word-form') as HTMLFormElement;\n    const wordInput = document.getElementById('word-input') as HTMLInputElement;\n    const resultDiv = document.getElementById('result') as HTMLDivElement;\n    const elementContainer = document.getElementById('element-container') as HTMLDivElement;\n    const themeRadios = document.querySelectorAll('input[name=\"theme\"]') as NodeListOf<HTMLInputElement>;\n    const shareButton = document.getElementById('share-button') as HTMLButtonElement;\n    \n    // Color theme option\n    let useColoredElements = false;\n    \n    // Check for query parameter 'word'\n    const wordFromParam = getQueryParam('word');\n    \n    // Set up theme toggle event listeners\n    themeRadios.forEach(radio => {\n        radio.addEventListener('change', (e) => {\n            const target = e.target as HTMLInputElement;\n            setTheme(target.value as 'light' | 'dark');\n        });\n    });\n    \n    // Set up colored elements toggle\n    const coloredElementsToggle = document.getElementById('colored-elements') as HTMLInputElement;\n    if (coloredElementsToggle) {\n        coloredElementsToggle.addEventListener('change', () => {\n            useColoredElements = coloredElementsToggle.checked;\n            \n            // Re-process the current input with the new setting\n            const inputText = wordInput.value.trim();\n            if (inputText) {\n                processWordInput(inputText, elementContainer, resultDiv, useColoredElements);\n            }\n        });\n    }\n    \n    // Set up share button click handler\n    shareButton.addEventListener('click', () => {\n        // Only proceed if button is not disabled\n        if (!shareButton.disabled) {\n            const inputText = wordInput.value.trim();\n            if (inputText) {\n                shareUrl(inputText);\n            }\n        }\n    });\n    \n    // Prevent default form submission but still keep the form for accessibility\n    form.addEventListener('submit', (e) => {\n        e.preventDefault();\n    });\n    \n    // Process input as user types\n    wordInput.addEventListener('input', () => {\n        const inputText = wordInput.value.trim();\n        processWordInput(inputText, elementContainer, resultDiv, useColoredElements);\n    });\n    \n    // If there's a word parameter in the URL, use it to auto-populate input field\n    if (wordFromParam) {\n        wordInput.value = wordFromParam;\n        processWordInput(wordFromParam, elementContainer, resultDiv, useColoredElements);\n    } else {\n        // Ensure share button is disabled initially\n        shareButton.disabled = true;\n    }\n});\n"],
  "mappings": "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",
  "names": ["ElementType", "elementSymbol", "useColoredElements"]
}
